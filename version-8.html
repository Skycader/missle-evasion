<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Airplane Dodge Game</title>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #000;
        position: relative;
      }
      canvas {
        border: 1px solid #fff;
        max-width: 100%;
        max-height: 100%;
      }
      #fullscreenButton {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 10px 20px;
        background: linear-gradient(#4caf50, #45a049);
        color: white;
        border: 2px solid white;
        border-radius: 10px;
        cursor: pointer;
        font-size: 16px;
        z-index: 10;
      }
      #fullscreenButton:hover {
        background: linear-gradient(#45a049, #4caf50);
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="1920" height="1080"></canvas>
    <button id="fullscreenButton">Full Screen</button>
    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game variables
      let plane = {
        x: 960,
        y: 100,
        width: 60,
        height: 20,
        speed: 5,
        trail: [],
      };
      let keys = {};
      let missiles = [];
      let bombs = [];
      let explosions = [];
      let score = 0;
      let gameOver = false;
      let gameWon = false;
      let lastBombDrop = 0;
      const bombCooldown = 500;

      // Air defense stations
      const stations = [
        {
          x: 200,
          y: 1030,
          width: 50,
          height: 50,
          lastLaunch: 0,
          launchInterval: 2000 + Math.random() * 2000,
          health: 100,
          destroyed: false,
        },
        {
          x: 960,
          y: 1030,
          width: 50,
          height: 50,
          lastLaunch: 0,
          launchInterval: 2000 + Math.random() * 2000,
          health: 100,
          destroyed: false,
        },
        {
          x: 1720,
          y: 1030,
          width: 50,
          height: 50,
          lastLaunch: 0,
          launchInterval: 2000 + Math.random() * 2000,
          health: 100,
          destroyed: false,
        },
      ];

      let lastTimestamp = 0;

      // Full-screen button handling
      const fullscreenButton = document.getElementById("fullscreenButton");
      fullscreenButton.addEventListener("click", toggleFullScreen);

      function toggleFullScreen() {
        if (!document.fullscreenElement) {
          if (canvas.requestFullscreen) {
            canvas.requestFullscreen();
          } else if (canvas.mozRequestFullScreen) {
            canvas.mozRequestFullScreen();
          } else if (canvas.webkitRequestFullscreen) {
            canvas.webkitRequestFullscreen();
          } else if (canvas.msRequestFullscreen) {
            canvas.msRequestFullscreen();
          }
          fullscreenButton.textContent = "Exit Full Screen";
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
          fullscreenButton.textContent = "Full Screen";
        }
      }

      // Input and click handling
      window.addEventListener("keydown", (e) => {
        keys[e.key] = true;
        if (
          e.key === " " &&
          !gameOver &&
          !gameWon &&
          performance.now() - lastBombDrop > bombCooldown
        ) {
          dropBomb();
          lastBombDrop = performance.now();
        }
      });
      window.addEventListener("keyup", (e) => (keys[e.key] = false));
      canvas.addEventListener("click", (event) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        if (
          (gameOver || gameWon) &&
          clickX >= 860 &&
          clickX <= 1060 &&
          clickY >= 490 &&
          clickY <= 590
        ) {
          resetGame();
        }
      });

      // Function to reset the game
      function resetGame() {
        plane = { x: 960, y: 100, width: 60, height: 20, speed: 5, trail: [] };
        missiles = [];
        bombs = [];
        explosions = [];
        score = 0;
        gameOver = false;
        gameWon = false;
        lastBombDrop = 0;
        stations.forEach((station) => {
          station.lastLaunch = 0;
          station.launchInterval = 2000 + Math.random() * 2000;
          station.health = 100;
          station.destroyed = false;
        });
      }

      // Function to drop a bomb
      function dropBomb() {
        const bomb = {
          x: plane.x + plane.width / 2,
          y: plane.y + plane.height,
          radius: 5,
          vx: 0,
          vy: 5,
          trail: [],
        };
        bombs.push(bomb);
      }

      // Function to update and draw smoke trails
      function updateAndDrawTrail(trail, x, y) {
        trail.push({ x, y, age: 0 });
        ctx.fillStyle = "rgba(200, 200, 200, 0.5)";
        trail.forEach((particle, index) => {
          particle.age += 1;
          if (particle.age > 30) {
            trail.splice(index, 1);
            return;
          }
          const alpha = 1 - particle.age / 30;
          ctx.beginPath();
          ctx.arc(
            particle.x,
            particle.y,
            3 * (1 - particle.age / 30),
            0,
            Math.PI * 2
          );
          ctx.fillStyle = `rgba(200, 200, 200, ${alpha})`;
          ctx.fill();
        });
      }

      // Function to draw the plane
      function drawPlane() {
        const trailX = plane.x + plane.width / 4;
        const trailY = plane.y + plane.height / 2;
        updateAndDrawTrail(plane.trail, trailX, trailY);

        ctx.fillStyle = "#4682B4";
        ctx.beginPath();
        ctx.moveTo(plane.x + plane.width, plane.y + plane.height / 2);
        ctx.lineTo(plane.x + plane.width * 0.7, plane.y);
        ctx.lineTo(plane.x + plane.width * 0.4, plane.y);
        ctx.lineTo(plane.x + plane.width * 0.2, plane.y + plane.height * 0.3);
        ctx.lineTo(plane.x, plane.y + plane.height * 0.3);
        ctx.lineTo(plane.x + plane.width * 0.2, plane.y + plane.height * 0.7);
        ctx.lineTo(plane.x + plane.width * 0.4, plane.y + plane.height);
        ctx.lineTo(plane.x + plane.width * 0.7, plane.y + plane.height);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(plane.x + plane.width * 0.7, plane.y + plane.height * 0.3);
        ctx.lineTo(plane.x + plane.width * 0.9, plane.y + plane.height / 2);
        ctx.lineTo(plane.x + plane.width * 0.7, plane.y + plane.height * 0.7);
        ctx.closePath();
        ctx.fill();
      }

      // Function to draw missiles
      function drawMissiles() {
        missiles.forEach((missile) => {
          if (missile.exploding) return;

          if (missile.fuel > 0) {
            const trailX =
              missile.x +
              missile.width / 2 -
              (Math.cos(missile.angle) * missile.height) / 2;
            const trailY =
              missile.y +
              missile.height / 2 -
              (Math.sin(missile.angle) * missile.height) / 2;
            updateAndDrawTrail(missile.trail, trailX, trailY);
          }

          ctx.save();
          ctx.translate(
            missile.x + missile.width / 2,
            missile.y + missile.height / 2
          );
          ctx.rotate(missile.angle);
          ctx.fillStyle = "#B22222";
          ctx.beginPath();
          ctx.moveTo(0, -missile.height / 2);
          ctx.lineTo(-missile.width / 2, -missile.height / 4);
          ctx.lineTo(-missile.width / 2, missile.height / 2);
          ctx.lineTo(0, missile.height / 2 + 5);
          ctx.lineTo(missile.width / 2, missile.height / 2);
          ctx.lineTo(missile.width / 2, -missile.height / 4);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#555";
          ctx.beginPath();
          ctx.moveTo(-missile.width / 2, missile.height / 4);
          ctx.lineTo(-missile.width, missile.height / 4);
          ctx.lineTo(-missile.width / 2, missile.height / 2);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(missile.width / 2, missile.height / 4);
          ctx.lineTo(missile.width, missile.height / 4);
          ctx.lineTo(missile.width / 2, missile.height / 2);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        });
      }

      // Function to draw bombs
      function drawBombs() {
        bombs.forEach((bomb) => {
          updateAndDrawTrail(bomb.trail, bomb.x, bomb.y);
          ctx.fillStyle = "#555";
          ctx.beginPath();
          ctx.arc(bomb.x, bomb.y, bomb.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      // Function to draw air defense stations
      function drawStations() {
        stations.forEach((station) => {
          if (!station.destroyed) {
            ctx.fillStyle = "#2E8B57";
            ctx.fillRect(station.x, station.y, station.width, station.height);
            ctx.fillStyle = "#555";
            ctx.fillRect(station.x + 10, station.y - 20, 30, 20);
          }
        });
      }

      // Function to draw explosions
      function drawExplosions() {
        explosions.forEach((expl) => {
          ctx.fillStyle = `rgba(255, 165, 0, ${1 - expl.frame / 20})`;
          ctx.beginPath();
          ctx.arc(expl.x, expl.y, expl.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      // Function to update plane position
      function updatePlane() {
        if (keys["ArrowUp"] && plane.y > 0) plane.y -= plane.speed;
        if (keys["ArrowDown"] && plane.y < canvas.height - plane.height)
          plane.y += plane.speed;
        if (keys["ArrowLeft"] && plane.x > 0) plane.x -= plane.speed;
        if (keys["ArrowRight"] && plane.x < canvas.width - plane.width)
          plane.x += plane.speed;
      }

      // Function to spawn a missile from a station
      function spawnMissile(station, timestamp) {
        const targetX = plane.x + plane.width / 2;
        const targetY = plane.y + plane.height / 2;
        const initialAngle = -Math.PI / 2;
        const missile = {
          x: station.x + station.width / 2,
          y: station.y - 20,
          width: 10,
          height: 30,
          speed: 2,
          maxSpeed: 4 + score / 10000,
          fuel: 150 + Math.random() * 50,
          angle: initialAngle,
          turnRate: 0.02,
          trail: [],
          exploding: false,
          vx: Math.cos(initialAngle) * 2,
          vy: Math.sin(initialAngle) * 2,
          accel: 0.1,
          postFuelTurnRate: 0.005,
          climbHeight: 0,
        };
        missiles.push(missile);
        station.lastLaunch = timestamp;
      }

      // Function to update missiles
      function updateMissiles() {
        const gravity = 0.1;
        missiles.forEach((missile, index) => {
          if (missile.exploding) return;

          if (missile.fuel > 0) {
            missile.fuel -= 1;
            missile.vx += Math.cos(missile.angle) * missile.accel;
            missile.vy += Math.sin(missile.angle) * missile.accel;

            const currentSpeed = Math.sqrt(
              missile.vx * missile.vx + missile.vy * missile.vy
            );
            if (currentSpeed > missile.maxSpeed) {
              const scale = missile.maxSpeed / currentSpeed;
              missile.vx *= scale;
              missile.vy *= scale;
            }

            const targetX = plane.x + plane.width / 2;
            const targetY = plane.y + plane.height / 2;
            const dx = targetX - (missile.x + missile.width / 2);
            const dy = targetY - (missile.y + missile.height / 2);
            const targetAngle = Math.atan2(dy, dx);
            let angleDiff = targetAngle - missile.angle;
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

            missile.climbHeight += Math.abs(missile.vy);
            if (missile.climbHeight < 200) {
              missile.angle = -Math.PI / 2;
            } else {
              missile.angle += Math.max(
                -missile.turnRate,
                Math.min(missile.turnRate, angleDiff)
              );
              const speed = Math.sqrt(
                missile.vx * missile.vx + missile.vy * missile.vy
              );
              missile.vx = Math.cos(missile.angle) * speed;
              missile.vy = Math.sin(missile.angle) * speed;
            }
          } else {
            // Inertia phase: apply gravity, no angle adjustment
            missile.vy += gravity; // Apply downward acceleration
            missile.vx *= 0.99; // Slight horizontal drag
          }

          missile.x += missile.vx;
          missile.y += missile.vy;

          if (missile.y >= canvas.height) {
            missile.exploding = true;
            explosions.push({
              x: missile.x + missile.width / 2,
              y: canvas.height,
              radius: 30,
              frame: 0,
            });
            missiles.splice(index, 1);
            return;
          }

          if (
            missile.y < -missile.height ||
            missile.x < -missile.width ||
            missile.x > canvas.width
          ) {
            missiles.splice(index, 1);
          }
        });
      }

      // Function to update bombs
      function updateBombs() {
        bombs.forEach((bomb, index) => {
          bomb.x += bomb.vx;
          bomb.y += bomb.vy;
          if (bomb.y >= canvas.height) {
            bombs.splice(index, 1);
          }
        });
      }

      // Function to check bomb collisions with stations
      function checkBombCollisions() {
        bombs.forEach((bomb, bombIndex) => {
          stations.forEach((station) => {
            if (station.destroyed) return;
            if (
              bomb.x >= station.x &&
              bomb.x <= station.x + station.width &&
              bomb.y >= station.y &&
              bomb.y <= station.y + station.height
            ) {
              station.health -= 50;
              bombs.splice(bombIndex, 1);
              explosions.push({
                x: bomb.x,
                y: bomb.y,
                radius: 20,
                frame: 0,
              });
              if (station.health <= 0) {
                station.destroyed = true;
              }
            }
          });
        });
      }

      // Update explosions
      function updateExplosions() {
        explosions.forEach((expl, index) => {
          expl.frame += 1;
          expl.radius += 1;
          if (expl.frame > 20) explosions.splice(index, 1);
        });
      }

      // Collision detection with missiles and explosions
      function checkCollisions() {
        missiles.forEach((missile) => {
          if (missile.exploding) return;
          if (
            missile.x < plane.x + plane.width &&
            missile.x + missile.width > plane.x &&
            missile.y < plane.y + plane.height &&
            missile.y + missile.height > plane.y
          ) {
            gameOver = true;
          }
        });

        explosions.forEach((expl) => {
          const distX = Math.abs(expl.x - (plane.x + plane.width / 2));
          const distY = Math.abs(expl.y - (plane.y + plane.height / 2));
          if (distX > plane.width / 2 + expl.radius) return;
          if (distY > plane.height / 2 + expl.radius) return;
          if (distX <= plane.width / 2 || distY <= plane.height / 2) {
            gameOver = true;
          } else {
            const dx = distX - plane.width / 2;
            const dy = distY - plane.height / 2;
            if (dx * dx + dy * dy <= expl.radius * expl.radius) {
              gameOver = true;
            }
          }
        });
      }

      // Draw score
      function drawScore() {
        ctx.fillStyle = "white";
        ctx.font = "20px Arial";
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 30);
      }

      // Draw restart button
      function drawRestartButton() {
        if (gameOver || gameWon) {
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(860, 490);
          ctx.lineTo(1060, 490);
          ctx.arcTo(1060, 540, 1010, 590, 25);
          ctx.arcTo(860, 590, 860, 540, 25);
          ctx.closePath();
          const grd = ctx.createLinearGradient(860, 490, 1060, 590);
          grd.addColorStop(0, "#4CAF50");
          grd.addColorStop(1, "#45a049");
          ctx.fillStyle = grd;
          ctx.fill();
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.fillStyle = "white";
          ctx.font = "20px Arial";
          ctx.fillText("Restart", 910, 550);
          ctx.restore();
        }
      }

      // Game over screen
      function drawGameOver() {
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("Game Over", canvas.width / 2 - 240, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText(
          `Final Score: ${Math.floor(score)}`,
          canvas.width / 2 - 80,
          canvas.height / 2 + 40
        );
        drawRestartButton();
      }

      // Game won screen
      function drawGameWon() {
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("You Win!", canvas.width / 2 - 80, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText(
          `Final Score: ${Math.floor(score)}`,
          canvas.width / 2 - 80,
          canvas.height / 2 + 40
        );
        drawRestartButton();
      }

      // Main game loop
      function gameLoop(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const delta = timestamp - lastTimestamp;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!gameOver && !gameWon) {
          updatePlane();
          updateMissiles();
          updateBombs();
          updateExplosions();
          checkCollisions();
          checkBombCollisions();

          stations.forEach((station) => {
            if (
              !station.destroyed &&
              timestamp - station.lastLaunch > station.launchInterval
            ) {
              spawnMissile(station, timestamp);
              station.launchInterval = 2000 + Math.random() * 2000;
            }
          });

          score += delta / 1000 / 60;

          if (stations.every((station) => station.destroyed)) {
            gameWon = true;
          }

          drawPlane();
          drawMissiles();
          drawBombs();
          drawExplosions();
          drawStations();
          drawScore();
        } else if (gameOver) {
          drawGameOver();
        } else if (gameWon) {
          drawGameWon();
        }

        lastTimestamp = timestamp;
        requestAnimationFrame(gameLoop);
      }

      // Start the game
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
